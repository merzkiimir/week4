#include <iostream>
#include <tchar.h>
#include <cmath>
#include <string>

// ********************************************************

	//Задание 4. Указатели
	//Объявите объекты разных типов и проинициализируйте их.
	//Объявите указатели соответствующих типов и проинициализируйте их
	//адресами заданных объектов. 
	//Выполняя задание, с помощью отладчика посмотрите, какие значения
	//будут присвоены переменным-указателям и на что эти указатели
	//"указывают"
	int main(){
      
		bool b = true;
		char c = 'q';
		short s = 12000;
		int i = 100000;
		float f = 17.0;
		double d = 18.12343434;

		bool *pB = &b; //pB = 0x62ff07, *pB = b
		char *pC = &c; //pC = 0x62ff06, *pC = c
		short *pS = &s; //pS = 0x62ff04, *pS = s
		int *pI = &i; // pI = 0x62ff00, *pI = i
		float *pf = &f; // pf = 0x62fefc, *pf = f
		double *pD = &d; //pD = 0x62fef0, *pD = d

	


	//Задание 4а. Объявите указатель на тип char и проинициализируйте
	//его адресом строкового литерала. Присвойте переменной типа char значение
	//любого элемента строки.
	//Проверьте - возможно ли присвоить какое-либо значение по адресу,
	//задаваемому указателем?
	
		const char* str = "Hello";
		char c = str[1];// c = 101 'e'
		//str[2] = 'A'; Нельзя изменить значение используя указатель, т.к. строковый литерал находится в
						//памяти доступной только для чтения

	

	//Задание 5. Арифметика указателей. Операция разыменования указателя.
	//Выполняя задание, следите за изменением значений
	//указателей и значений объектов, на которые они указывают.
	//Интерпретируте наблюдаемые результаты
	
		int nAr[3] = {1,3}; // [0] = 1, [1] = 3, [2] = 0
		int* pn = &nAr[0]; // pn = 0x62fee8, *pn = 1
		(*pn)++;	//0-й элемент массива nAr увеличился на 1, т.к. указатель pn содержал адрес 0-го элемента
		pn++;	//указатель сдвинулся на следующий элемент (1-й, если считать с 0-го элемента)
        // pn = 0x62feec

		char cAr[]={'A','B','C','D'};
		char* pc = &cAr[0]; //pc содержит адрес 0-го элемента массива cAr
		(*pc)=(*pc)+5;	//взятие значения по адресу pc 'A' (65) и увеличение его на 5, 
						//в результате получается значение 'F' (70), которое будет записано 
						//по адресу pc вместо 0-го элемента
		pc=pc+3;	//указатель указывает на 3-й элемент массива cAr (счет с 0-го)
        // *pc = 68 'D'
	
		double dAr[3]={1.0,2.0};
		double* pd1 = &dAr[0];
		double* pd2 = pd1;
		(*pd2)+=2; //pd2 - указывает на 0-й элемент. После разыменования и прибавления 2,
				   //значение 0-го элемента изменится на 3.0. 
		pd2+=2; //указатель pd2, теперь указывает на 2-й элемент (счет с 0-го)

		//Объясните результат выполнения операции
		//вычитания двух указателей
		pd1 = &dAr[0];
		pd2 = &dAr[1];
		int nNumber=pd2 - pd1; //операция вычитания указателей имеет смысл для определения 
							   //количества элементов между двумя указателями в рамках одного массива
							   //nNumber = 1

		//Сравните указатели pd2 и pd1 и с помощью cout
		//выведите результаты сравнения.
		std::cout << "5. Compare result is: " << (pd2 > pd1 ? "true" : "false") << std::endl;
    }
		
